// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public struct FBACC: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_2_10() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case reqId = 4
    case msTime = 6
    case nsTimestamp = 8
    case x = 10
    case y = 12
    case z = 14
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var reqId: String? { let o = _accessor.offset(VTOFFSET.reqId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var reqIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.reqId.v) }
  public var msTime: Int64 { let o = _accessor.offset(VTOFFSET.msTime.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
  public var nsTimestamp: Int64 { let o = _accessor.offset(VTOFFSET.nsTimestamp.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
  public var x: Double { let o = _accessor.offset(VTOFFSET.x.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var y: Double { let o = _accessor.offset(VTOFFSET.y.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var z: Double { let o = _accessor.offset(VTOFFSET.z.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public static func startFBACC(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 6) }
  public static func add(reqId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: reqId, at: VTOFFSET.reqId.p) }
  public static func add(msTime: Int64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: msTime, def: 0, at: VTOFFSET.msTime.p) }
  public static func add(nsTimestamp: Int64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: nsTimestamp, def: 0, at: VTOFFSET.nsTimestamp.p) }
  public static func add(x: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: x, def: 0.0, at: VTOFFSET.x.p) }
  public static func add(y: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: y, def: 0.0, at: VTOFFSET.y.p) }
  public static func add(z: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: z, def: 0.0, at: VTOFFSET.z.p) }
  public static func endFBACC(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createFBACC(
    _ fbb: inout FlatBufferBuilder,
    reqIdOffset reqId: Offset = Offset(),
    msTime: Int64 = 0,
    nsTimestamp: Int64 = 0,
    x: Double = 0.0,
    y: Double = 0.0,
    z: Double = 0.0
  ) -> Offset {
    let __start = FBACC.startFBACC(&fbb)
    FBACC.add(reqId: reqId, &fbb)
    FBACC.add(msTime: msTime, &fbb)
    FBACC.add(nsTimestamp: nsTimestamp, &fbb)
    FBACC.add(x: x, &fbb)
    FBACC.add(y: y, &fbb)
    FBACC.add(z: z, &fbb)
    return FBACC.endFBACC(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.reqId.p, fieldName: "reqId", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.msTime.p, fieldName: "msTime", required: false, type: Int64.self)
    try _v.visit(field: VTOFFSET.nsTimestamp.p, fieldName: "nsTimestamp", required: false, type: Int64.self)
    try _v.visit(field: VTOFFSET.x.p, fieldName: "x", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.y.p, fieldName: "y", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.z.p, fieldName: "z", required: false, type: Double.self)
    _v.finish()
  }
}

public struct FBACCs: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_2_10() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case accs = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var hasAccs: Bool { let o = _accessor.offset(VTOFFSET.accs.v); return o == 0 ? false : true }
  public var accsCount: Int32 { let o = _accessor.offset(VTOFFSET.accs.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func accs(at index: Int32) -> FBACC? { let o = _accessor.offset(VTOFFSET.accs.v); return o == 0 ? nil : FBACC(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startFBACCs(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func addVectorOf(accs: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: accs, at: VTOFFSET.accs.p) }
  public static func endFBACCs(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createFBACCs(
    _ fbb: inout FlatBufferBuilder,
    accsVectorOffset accs: Offset = Offset()
  ) -> Offset {
    let __start = FBACCs.startFBACCs(&fbb)
    FBACCs.addVectorOf(accs: accs, &fbb)
    return FBACCs.endFBACCs(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.accs.p, fieldName: "accs", required: false, type: ForwardOffset<Vector<ForwardOffset<FBACC>, FBACC>>.self)
    _v.finish()
  }
}

public struct FBALGORITHM: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_2_10() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case reqId = 4
    case msTime = 6
    case gpsTime = 8
    case nsTimestamp = 10
    case latitude = 12
    case longitude = 14
    case altitude = 16
    case accuracy = 18
    case provider = 20
    case speed = 22
    case bearing = 24
    case speedAccuracy = 26
    case verticalAccuracy = 28
    case bearingAccuracy = 30
    case floorDisplayName = 32
    case parkingLotId = 34
    case sourceCode = 36
    case scc = 38
    case scr = 40
    case x = 42
    case y = 44
    case absoluteHeading = 46
    case velocity = 48
    case phase = 50
    case calculatedTime = 52
    case mode = 54
    case isIndoor = 56
    case isCarConnected = 58
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var reqId: String? { let o = _accessor.offset(VTOFFSET.reqId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var reqIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.reqId.v) }
  public var msTime: Int64 { let o = _accessor.offset(VTOFFSET.msTime.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
  public var gpsTime: Int64 { let o = _accessor.offset(VTOFFSET.gpsTime.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
  public var nsTimestamp: Int64 { let o = _accessor.offset(VTOFFSET.nsTimestamp.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
  public var latitude: Double { let o = _accessor.offset(VTOFFSET.latitude.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var longitude: Double { let o = _accessor.offset(VTOFFSET.longitude.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var altitude: Double { let o = _accessor.offset(VTOFFSET.altitude.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var accuracy: Double { let o = _accessor.offset(VTOFFSET.accuracy.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var provider: String? { let o = _accessor.offset(VTOFFSET.provider.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var providerSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.provider.v) }
  public var speed: Double { let o = _accessor.offset(VTOFFSET.speed.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var bearing: Double { let o = _accessor.offset(VTOFFSET.bearing.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var speedAccuracy: Double { let o = _accessor.offset(VTOFFSET.speedAccuracy.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var verticalAccuracy: Double { let o = _accessor.offset(VTOFFSET.verticalAccuracy.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var bearingAccuracy: Double { let o = _accessor.offset(VTOFFSET.bearingAccuracy.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var floorDisplayName: String? { let o = _accessor.offset(VTOFFSET.floorDisplayName.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var floorDisplayNameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.floorDisplayName.v) }
  public var parkingLotId: Int64 { let o = _accessor.offset(VTOFFSET.parkingLotId.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
  public var sourceCode: String? { let o = _accessor.offset(VTOFFSET.sourceCode.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var sourceCodeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.sourceCode.v) }
  public var scc: Double { let o = _accessor.offset(VTOFFSET.scc.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var scr: Double { let o = _accessor.offset(VTOFFSET.scr.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var x: Double { let o = _accessor.offset(VTOFFSET.x.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var y: Double { let o = _accessor.offset(VTOFFSET.y.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var absoluteHeading: Double { let o = _accessor.offset(VTOFFSET.absoluteHeading.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var velocity: Double { let o = _accessor.offset(VTOFFSET.velocity.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var phase: Int64 { let o = _accessor.offset(VTOFFSET.phase.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
  public var calculatedTime: Double { let o = _accessor.offset(VTOFFSET.calculatedTime.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var mode: String? { let o = _accessor.offset(VTOFFSET.mode.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var modeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.mode.v) }
  public var isIndoor: Bool { let o = _accessor.offset(VTOFFSET.isIndoor.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public var isCarConnected: Bool { let o = _accessor.offset(VTOFFSET.isCarConnected.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public static func startFBALGORITHM(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 28) }
  public static func add(reqId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: reqId, at: VTOFFSET.reqId.p) }
  public static func add(msTime: Int64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: msTime, def: 0, at: VTOFFSET.msTime.p) }
  public static func add(gpsTime: Int64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: gpsTime, def: 0, at: VTOFFSET.gpsTime.p) }
  public static func add(nsTimestamp: Int64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: nsTimestamp, def: 0, at: VTOFFSET.nsTimestamp.p) }
  public static func add(latitude: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: latitude, def: 0.0, at: VTOFFSET.latitude.p) }
  public static func add(longitude: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: longitude, def: 0.0, at: VTOFFSET.longitude.p) }
  public static func add(altitude: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: altitude, def: 0.0, at: VTOFFSET.altitude.p) }
  public static func add(accuracy: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: accuracy, def: 0.0, at: VTOFFSET.accuracy.p) }
  public static func add(provider: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: provider, at: VTOFFSET.provider.p) }
  public static func add(speed: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: speed, def: 0.0, at: VTOFFSET.speed.p) }
  public static func add(bearing: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: bearing, def: 0.0, at: VTOFFSET.bearing.p) }
  public static func add(speedAccuracy: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: speedAccuracy, def: 0.0, at: VTOFFSET.speedAccuracy.p) }
  public static func add(verticalAccuracy: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: verticalAccuracy, def: 0.0, at: VTOFFSET.verticalAccuracy.p) }
  public static func add(bearingAccuracy: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: bearingAccuracy, def: 0.0, at: VTOFFSET.bearingAccuracy.p) }
  public static func add(floorDisplayName: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: floorDisplayName, at: VTOFFSET.floorDisplayName.p) }
  public static func add(parkingLotId: Int64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: parkingLotId, def: 0, at: VTOFFSET.parkingLotId.p) }
  public static func add(sourceCode: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: sourceCode, at: VTOFFSET.sourceCode.p) }
  public static func add(scc: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: scc, def: 0.0, at: VTOFFSET.scc.p) }
  public static func add(scr: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: scr, def: 0.0, at: VTOFFSET.scr.p) }
  public static func add(x: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: x, def: 0.0, at: VTOFFSET.x.p) }
  public static func add(y: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: y, def: 0.0, at: VTOFFSET.y.p) }
  public static func add(absoluteHeading: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: absoluteHeading, def: 0.0, at: VTOFFSET.absoluteHeading.p) }
  public static func add(velocity: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: velocity, def: 0.0, at: VTOFFSET.velocity.p) }
  public static func add(phase: Int64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: phase, def: 0, at: VTOFFSET.phase.p) }
  public static func add(calculatedTime: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: calculatedTime, def: 0.0, at: VTOFFSET.calculatedTime.p) }
  public static func add(mode: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: mode, at: VTOFFSET.mode.p) }
  public static func add(isIndoor: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: isIndoor, def: false,
   at: VTOFFSET.isIndoor.p) }
  public static func add(isCarConnected: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: isCarConnected, def: false,
   at: VTOFFSET.isCarConnected.p) }
  public static func endFBALGORITHM(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createFBALGORITHM(
    _ fbb: inout FlatBufferBuilder,
    reqIdOffset reqId: Offset = Offset(),
    msTime: Int64 = 0,
    gpsTime: Int64 = 0,
    nsTimestamp: Int64 = 0,
    latitude: Double = 0.0,
    longitude: Double = 0.0,
    altitude: Double = 0.0,
    accuracy: Double = 0.0,
    providerOffset provider: Offset = Offset(),
    speed: Double = 0.0,
    bearing: Double = 0.0,
    speedAccuracy: Double = 0.0,
    verticalAccuracy: Double = 0.0,
    bearingAccuracy: Double = 0.0,
    floorDisplayNameOffset floorDisplayName: Offset = Offset(),
    parkingLotId: Int64 = 0,
    sourceCodeOffset sourceCode: Offset = Offset(),
    scc: Double = 0.0,
    scr: Double = 0.0,
    x: Double = 0.0,
    y: Double = 0.0,
    absoluteHeading: Double = 0.0,
    velocity: Double = 0.0,
    phase: Int64 = 0,
    calculatedTime: Double = 0.0,
    modeOffset mode: Offset = Offset(),
    isIndoor: Bool = false,
    isCarConnected: Bool = false
  ) -> Offset {
    let __start = FBALGORITHM.startFBALGORITHM(&fbb)
    FBALGORITHM.add(reqId: reqId, &fbb)
    FBALGORITHM.add(msTime: msTime, &fbb)
    FBALGORITHM.add(gpsTime: gpsTime, &fbb)
    FBALGORITHM.add(nsTimestamp: nsTimestamp, &fbb)
    FBALGORITHM.add(latitude: latitude, &fbb)
    FBALGORITHM.add(longitude: longitude, &fbb)
    FBALGORITHM.add(altitude: altitude, &fbb)
    FBALGORITHM.add(accuracy: accuracy, &fbb)
    FBALGORITHM.add(provider: provider, &fbb)
    FBALGORITHM.add(speed: speed, &fbb)
    FBALGORITHM.add(bearing: bearing, &fbb)
    FBALGORITHM.add(speedAccuracy: speedAccuracy, &fbb)
    FBALGORITHM.add(verticalAccuracy: verticalAccuracy, &fbb)
    FBALGORITHM.add(bearingAccuracy: bearingAccuracy, &fbb)
    FBALGORITHM.add(floorDisplayName: floorDisplayName, &fbb)
    FBALGORITHM.add(parkingLotId: parkingLotId, &fbb)
    FBALGORITHM.add(sourceCode: sourceCode, &fbb)
    FBALGORITHM.add(scc: scc, &fbb)
    FBALGORITHM.add(scr: scr, &fbb)
    FBALGORITHM.add(x: x, &fbb)
    FBALGORITHM.add(y: y, &fbb)
    FBALGORITHM.add(absoluteHeading: absoluteHeading, &fbb)
    FBALGORITHM.add(velocity: velocity, &fbb)
    FBALGORITHM.add(phase: phase, &fbb)
    FBALGORITHM.add(calculatedTime: calculatedTime, &fbb)
    FBALGORITHM.add(mode: mode, &fbb)
    FBALGORITHM.add(isIndoor: isIndoor, &fbb)
    FBALGORITHM.add(isCarConnected: isCarConnected, &fbb)
    return FBALGORITHM.endFBALGORITHM(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.reqId.p, fieldName: "reqId", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.msTime.p, fieldName: "msTime", required: false, type: Int64.self)
    try _v.visit(field: VTOFFSET.gpsTime.p, fieldName: "gpsTime", required: false, type: Int64.self)
    try _v.visit(field: VTOFFSET.nsTimestamp.p, fieldName: "nsTimestamp", required: false, type: Int64.self)
    try _v.visit(field: VTOFFSET.latitude.p, fieldName: "latitude", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.longitude.p, fieldName: "longitude", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.altitude.p, fieldName: "altitude", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.accuracy.p, fieldName: "accuracy", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.provider.p, fieldName: "provider", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.speed.p, fieldName: "speed", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.bearing.p, fieldName: "bearing", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.speedAccuracy.p, fieldName: "speedAccuracy", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.verticalAccuracy.p, fieldName: "verticalAccuracy", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.bearingAccuracy.p, fieldName: "bearingAccuracy", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.floorDisplayName.p, fieldName: "floorDisplayName", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.parkingLotId.p, fieldName: "parkingLotId", required: false, type: Int64.self)
    try _v.visit(field: VTOFFSET.sourceCode.p, fieldName: "sourceCode", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.scc.p, fieldName: "scc", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.scr.p, fieldName: "scr", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.x.p, fieldName: "x", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.y.p, fieldName: "y", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.absoluteHeading.p, fieldName: "absoluteHeading", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.velocity.p, fieldName: "velocity", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.phase.p, fieldName: "phase", required: false, type: Int64.self)
    try _v.visit(field: VTOFFSET.calculatedTime.p, fieldName: "calculatedTime", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.mode.p, fieldName: "mode", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.isIndoor.p, fieldName: "isIndoor", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.isCarConnected.p, fieldName: "isCarConnected", required: false, type: Bool.self)
    _v.finish()
  }
}

public struct FBALGORITHMs: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_2_10() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case algorithms = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var hasAlgorithms: Bool { let o = _accessor.offset(VTOFFSET.algorithms.v); return o == 0 ? false : true }
  public var algorithmsCount: Int32 { let o = _accessor.offset(VTOFFSET.algorithms.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func algorithms(at index: Int32) -> FBALGORITHM? { let o = _accessor.offset(VTOFFSET.algorithms.v); return o == 0 ? nil : FBALGORITHM(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startFBALGORITHMs(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func addVectorOf(algorithms: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: algorithms, at: VTOFFSET.algorithms.p) }
  public static func endFBALGORITHMs(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createFBALGORITHMs(
    _ fbb: inout FlatBufferBuilder,
    algorithmsVectorOffset algorithms: Offset = Offset()
  ) -> Offset {
    let __start = FBALGORITHMs.startFBALGORITHMs(&fbb)
    FBALGORITHMs.addVectorOf(algorithms: algorithms, &fbb)
    return FBALGORITHMs.endFBALGORITHMs(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.algorithms.p, fieldName: "algorithms", required: false, type: ForwardOffset<Vector<ForwardOffset<FBALGORITHM>, FBALGORITHM>>.self)
    _v.finish()
  }
}

public struct FBBLE_DEVICE: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_2_10() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case address = 4
    case name = 6
    case rssi = 8
    case scanTime = 10
    case txPower = 12
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var address: String? { let o = _accessor.offset(VTOFFSET.address.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var addressSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.address.v) }
  public var name: String? { let o = _accessor.offset(VTOFFSET.name.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var nameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.name.v) }
  public var rssi: Int64 { let o = _accessor.offset(VTOFFSET.rssi.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
  public var scanTime: Int64 { let o = _accessor.offset(VTOFFSET.scanTime.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
  public var txPower: Int64 { let o = _accessor.offset(VTOFFSET.txPower.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
  public static func startFBBLE_DEVICE(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 5) }
  public static func add(address: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: address, at: VTOFFSET.address.p) }
  public static func add(name: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: name, at: VTOFFSET.name.p) }
  public static func add(rssi: Int64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: rssi, def: 0, at: VTOFFSET.rssi.p) }
  public static func add(scanTime: Int64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: scanTime, def: 0, at: VTOFFSET.scanTime.p) }
  public static func add(txPower: Int64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: txPower, def: 0, at: VTOFFSET.txPower.p) }
  public static func endFBBLE_DEVICE(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createFBBLE_DEVICE(
    _ fbb: inout FlatBufferBuilder,
    addressOffset address: Offset = Offset(),
    nameOffset name: Offset = Offset(),
    rssi: Int64 = 0,
    scanTime: Int64 = 0,
    txPower: Int64 = 0
  ) -> Offset {
    let __start = FBBLE_DEVICE.startFBBLE_DEVICE(&fbb)
    FBBLE_DEVICE.add(address: address, &fbb)
    FBBLE_DEVICE.add(name: name, &fbb)
    FBBLE_DEVICE.add(rssi: rssi, &fbb)
    FBBLE_DEVICE.add(scanTime: scanTime, &fbb)
    FBBLE_DEVICE.add(txPower: txPower, &fbb)
    return FBBLE_DEVICE.endFBBLE_DEVICE(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.address.p, fieldName: "address", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.name.p, fieldName: "name", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.rssi.p, fieldName: "rssi", required: false, type: Int64.self)
    try _v.visit(field: VTOFFSET.scanTime.p, fieldName: "scanTime", required: false, type: Int64.self)
    try _v.visit(field: VTOFFSET.txPower.p, fieldName: "txPower", required: false, type: Int64.self)
    _v.finish()
  }
}

public struct FBBLE: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_2_10() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case bleList = 4
    case msTime = 6
    case reqId = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var hasBleList: Bool { let o = _accessor.offset(VTOFFSET.bleList.v); return o == 0 ? false : true }
  public var bleListCount: Int32 { let o = _accessor.offset(VTOFFSET.bleList.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func bleList(at index: Int32) -> FBBLE_DEVICE? { let o = _accessor.offset(VTOFFSET.bleList.v); return o == 0 ? nil : FBBLE_DEVICE(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public var msTime: Int64 { let o = _accessor.offset(VTOFFSET.msTime.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
  public var reqId: String? { let o = _accessor.offset(VTOFFSET.reqId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var reqIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.reqId.v) }
  public static func startFBBLE(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func addVectorOf(bleList: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: bleList, at: VTOFFSET.bleList.p) }
  public static func add(msTime: Int64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: msTime, def: 0, at: VTOFFSET.msTime.p) }
  public static func add(reqId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: reqId, at: VTOFFSET.reqId.p) }
  public static func endFBBLE(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createFBBLE(
    _ fbb: inout FlatBufferBuilder,
    bleListVectorOffset bleList: Offset = Offset(),
    msTime: Int64 = 0,
    reqIdOffset reqId: Offset = Offset()
  ) -> Offset {
    let __start = FBBLE.startFBBLE(&fbb)
    FBBLE.addVectorOf(bleList: bleList, &fbb)
    FBBLE.add(msTime: msTime, &fbb)
    FBBLE.add(reqId: reqId, &fbb)
    return FBBLE.endFBBLE(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.bleList.p, fieldName: "bleList", required: false, type: ForwardOffset<Vector<ForwardOffset<FBBLE_DEVICE>, FBBLE_DEVICE>>.self)
    try _v.visit(field: VTOFFSET.msTime.p, fieldName: "msTime", required: false, type: Int64.self)
    try _v.visit(field: VTOFFSET.reqId.p, fieldName: "reqId", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

public struct FBBLEs: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_2_10() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case bles = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var hasBles: Bool { let o = _accessor.offset(VTOFFSET.bles.v); return o == 0 ? false : true }
  public var blesCount: Int32 { let o = _accessor.offset(VTOFFSET.bles.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func bles(at index: Int32) -> FBBLE? { let o = _accessor.offset(VTOFFSET.bles.v); return o == 0 ? nil : FBBLE(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startFBBLEs(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func addVectorOf(bles: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: bles, at: VTOFFSET.bles.p) }
  public static func endFBBLEs(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createFBBLEs(
    _ fbb: inout FlatBufferBuilder,
    blesVectorOffset bles: Offset = Offset()
  ) -> Offset {
    let __start = FBBLEs.startFBBLEs(&fbb)
    FBBLEs.addVectorOf(bles: bles, &fbb)
    return FBBLEs.endFBBLEs(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.bles.p, fieldName: "bles", required: false, type: ForwardOffset<Vector<ForwardOffset<FBBLE>, FBBLE>>.self)
    _v.finish()
  }
}

public struct FBGPS: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_2_10() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case reqId = 4
    case msTime = 6
    case gpsTime = 8
    case nsTimestamp = 10
    case latitude = 12
    case longitude = 14
    case altitude = 16
    case accuracy = 18
    case provider = 20
    case speed = 22
    case bearing = 24
    case speedAccuracy = 26
    case verticalAccuracy = 28
    case bearingAccuracy = 30
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var reqId: String? { let o = _accessor.offset(VTOFFSET.reqId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var reqIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.reqId.v) }
  public var msTime: Int64 { let o = _accessor.offset(VTOFFSET.msTime.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
  public var gpsTime: Int64 { let o = _accessor.offset(VTOFFSET.gpsTime.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
  public var nsTimestamp: Int64 { let o = _accessor.offset(VTOFFSET.nsTimestamp.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
  public var latitude: Double { let o = _accessor.offset(VTOFFSET.latitude.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var longitude: Double { let o = _accessor.offset(VTOFFSET.longitude.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var altitude: Double { let o = _accessor.offset(VTOFFSET.altitude.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var accuracy: Double { let o = _accessor.offset(VTOFFSET.accuracy.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var provider: String? { let o = _accessor.offset(VTOFFSET.provider.v); return o == 0 ? "gps" : _accessor.string(at: o) }
  public var providerSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.provider.v) }
  public var speed: Double { let o = _accessor.offset(VTOFFSET.speed.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var bearing: Double { let o = _accessor.offset(VTOFFSET.bearing.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var speedAccuracy: Double { let o = _accessor.offset(VTOFFSET.speedAccuracy.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var verticalAccuracy: Double { let o = _accessor.offset(VTOFFSET.verticalAccuracy.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var bearingAccuracy: Double { let o = _accessor.offset(VTOFFSET.bearingAccuracy.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public static func startFBGPS(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 14) }
  public static func add(reqId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: reqId, at: VTOFFSET.reqId.p) }
  public static func add(msTime: Int64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: msTime, def: 0, at: VTOFFSET.msTime.p) }
  public static func add(gpsTime: Int64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: gpsTime, def: 0, at: VTOFFSET.gpsTime.p) }
  public static func add(nsTimestamp: Int64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: nsTimestamp, def: 0, at: VTOFFSET.nsTimestamp.p) }
  public static func add(latitude: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: latitude, def: 0.0, at: VTOFFSET.latitude.p) }
  public static func add(longitude: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: longitude, def: 0.0, at: VTOFFSET.longitude.p) }
  public static func add(altitude: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: altitude, def: 0.0, at: VTOFFSET.altitude.p) }
  public static func add(accuracy: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: accuracy, def: 0.0, at: VTOFFSET.accuracy.p) }
  public static func add(provider: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: provider, at: VTOFFSET.provider.p) }
  public static func add(speed: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: speed, def: 0.0, at: VTOFFSET.speed.p) }
  public static func add(bearing: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: bearing, def: 0.0, at: VTOFFSET.bearing.p) }
  public static func add(speedAccuracy: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: speedAccuracy, def: 0.0, at: VTOFFSET.speedAccuracy.p) }
  public static func add(verticalAccuracy: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: verticalAccuracy, def: 0.0, at: VTOFFSET.verticalAccuracy.p) }
  public static func add(bearingAccuracy: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: bearingAccuracy, def: 0.0, at: VTOFFSET.bearingAccuracy.p) }
  public static func endFBGPS(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createFBGPS(
    _ fbb: inout FlatBufferBuilder,
    reqIdOffset reqId: Offset = Offset(),
    msTime: Int64 = 0,
    gpsTime: Int64 = 0,
    nsTimestamp: Int64 = 0,
    latitude: Double = 0.0,
    longitude: Double = 0.0,
    altitude: Double = 0.0,
    accuracy: Double = 0.0,
    providerOffset provider: Offset = Offset(),
    speed: Double = 0.0,
    bearing: Double = 0.0,
    speedAccuracy: Double = 0.0,
    verticalAccuracy: Double = 0.0,
    bearingAccuracy: Double = 0.0
  ) -> Offset {
    let __start = FBGPS.startFBGPS(&fbb)
    FBGPS.add(reqId: reqId, &fbb)
    FBGPS.add(msTime: msTime, &fbb)
    FBGPS.add(gpsTime: gpsTime, &fbb)
    FBGPS.add(nsTimestamp: nsTimestamp, &fbb)
    FBGPS.add(latitude: latitude, &fbb)
    FBGPS.add(longitude: longitude, &fbb)
    FBGPS.add(altitude: altitude, &fbb)
    FBGPS.add(accuracy: accuracy, &fbb)
    FBGPS.add(provider: provider, &fbb)
    FBGPS.add(speed: speed, &fbb)
    FBGPS.add(bearing: bearing, &fbb)
    FBGPS.add(speedAccuracy: speedAccuracy, &fbb)
    FBGPS.add(verticalAccuracy: verticalAccuracy, &fbb)
    FBGPS.add(bearingAccuracy: bearingAccuracy, &fbb)
    return FBGPS.endFBGPS(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.reqId.p, fieldName: "reqId", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.msTime.p, fieldName: "msTime", required: false, type: Int64.self)
    try _v.visit(field: VTOFFSET.gpsTime.p, fieldName: "gpsTime", required: false, type: Int64.self)
    try _v.visit(field: VTOFFSET.nsTimestamp.p, fieldName: "nsTimestamp", required: false, type: Int64.self)
    try _v.visit(field: VTOFFSET.latitude.p, fieldName: "latitude", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.longitude.p, fieldName: "longitude", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.altitude.p, fieldName: "altitude", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.accuracy.p, fieldName: "accuracy", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.provider.p, fieldName: "provider", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.speed.p, fieldName: "speed", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.bearing.p, fieldName: "bearing", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.speedAccuracy.p, fieldName: "speedAccuracy", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.verticalAccuracy.p, fieldName: "verticalAccuracy", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.bearingAccuracy.p, fieldName: "bearingAccuracy", required: false, type: Double.self)
    _v.finish()
  }
}

public struct FBGPSes: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_2_10() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case gpses = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var hasGpses: Bool { let o = _accessor.offset(VTOFFSET.gpses.v); return o == 0 ? false : true }
  public var gpsesCount: Int32 { let o = _accessor.offset(VTOFFSET.gpses.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func gpses(at index: Int32) -> FBGPS? { let o = _accessor.offset(VTOFFSET.gpses.v); return o == 0 ? nil : FBGPS(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startFBGPSes(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func addVectorOf(gpses: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: gpses, at: VTOFFSET.gpses.p) }
  public static func endFBGPSes(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createFBGPSes(
    _ fbb: inout FlatBufferBuilder,
    gpsesVectorOffset gpses: Offset = Offset()
  ) -> Offset {
    let __start = FBGPSes.startFBGPSes(&fbb)
    FBGPSes.addVectorOf(gpses: gpses, &fbb)
    return FBGPSes.endFBGPSes(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.gpses.p, fieldName: "gpses", required: false, type: ForwardOffset<Vector<ForwardOffset<FBGPS>, FBGPS>>.self)
    _v.finish()
  }
}

public struct FBGYRO: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_2_10() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case reqId = 4
    case msTime = 6
    case nsTimestamp = 8
    case x = 10
    case y = 12
    case z = 14
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var reqId: String? { let o = _accessor.offset(VTOFFSET.reqId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var reqIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.reqId.v) }
  public var msTime: Int64 { let o = _accessor.offset(VTOFFSET.msTime.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
  public var nsTimestamp: Int64 { let o = _accessor.offset(VTOFFSET.nsTimestamp.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
  public var x: Double { let o = _accessor.offset(VTOFFSET.x.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var y: Double { let o = _accessor.offset(VTOFFSET.y.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var z: Double { let o = _accessor.offset(VTOFFSET.z.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public static func startFBGYRO(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 6) }
  public static func add(reqId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: reqId, at: VTOFFSET.reqId.p) }
  public static func add(msTime: Int64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: msTime, def: 0, at: VTOFFSET.msTime.p) }
  public static func add(nsTimestamp: Int64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: nsTimestamp, def: 0, at: VTOFFSET.nsTimestamp.p) }
  public static func add(x: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: x, def: 0.0, at: VTOFFSET.x.p) }
  public static func add(y: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: y, def: 0.0, at: VTOFFSET.y.p) }
  public static func add(z: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: z, def: 0.0, at: VTOFFSET.z.p) }
  public static func endFBGYRO(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createFBGYRO(
    _ fbb: inout FlatBufferBuilder,
    reqIdOffset reqId: Offset = Offset(),
    msTime: Int64 = 0,
    nsTimestamp: Int64 = 0,
    x: Double = 0.0,
    y: Double = 0.0,
    z: Double = 0.0
  ) -> Offset {
    let __start = FBGYRO.startFBGYRO(&fbb)
    FBGYRO.add(reqId: reqId, &fbb)
    FBGYRO.add(msTime: msTime, &fbb)
    FBGYRO.add(nsTimestamp: nsTimestamp, &fbb)
    FBGYRO.add(x: x, &fbb)
    FBGYRO.add(y: y, &fbb)
    FBGYRO.add(z: z, &fbb)
    return FBGYRO.endFBGYRO(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.reqId.p, fieldName: "reqId", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.msTime.p, fieldName: "msTime", required: false, type: Int64.self)
    try _v.visit(field: VTOFFSET.nsTimestamp.p, fieldName: "nsTimestamp", required: false, type: Int64.self)
    try _v.visit(field: VTOFFSET.x.p, fieldName: "x", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.y.p, fieldName: "y", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.z.p, fieldName: "z", required: false, type: Double.self)
    _v.finish()
  }
}

public struct FBGYROs: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_2_10() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case gyros = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var hasGyros: Bool { let o = _accessor.offset(VTOFFSET.gyros.v); return o == 0 ? false : true }
  public var gyrosCount: Int32 { let o = _accessor.offset(VTOFFSET.gyros.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func gyros(at index: Int32) -> FBGYRO? { let o = _accessor.offset(VTOFFSET.gyros.v); return o == 0 ? nil : FBGYRO(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startFBGYROs(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func addVectorOf(gyros: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: gyros, at: VTOFFSET.gyros.p) }
  public static func endFBGYROs(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createFBGYROs(
    _ fbb: inout FlatBufferBuilder,
    gyrosVectorOffset gyros: Offset = Offset()
  ) -> Offset {
    let __start = FBGYROs.startFBGYROs(&fbb)
    FBGYROs.addVectorOf(gyros: gyros, &fbb)
    return FBGYROs.endFBGYROs(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.gyros.p, fieldName: "gyros", required: false, type: ForwardOffset<Vector<ForwardOffset<FBGYRO>, FBGYRO>>.self)
    _v.finish()
  }
}

public struct FBINDOOR_LOC: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_2_10() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case reqId = 4
    case msTime = 6
    case gpsTime = 8
    case nsTimestamp = 10
    case latitude = 12
    case longitude = 14
    case altitude = 16
    case accuracy = 18
    case provider = 20
    case speed = 22
    case bearing = 24
    case speedAccuracy = 26
    case verticalAccuracy = 28
    case bearingAccuracy = 30
    case floorDisplayName = 32
    case parkingLotId = 34
    case sourceCode = 36
    case validity = 38
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var reqId: String? { let o = _accessor.offset(VTOFFSET.reqId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var reqIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.reqId.v) }
  public var msTime: Int64 { let o = _accessor.offset(VTOFFSET.msTime.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
  public var gpsTime: Int64 { let o = _accessor.offset(VTOFFSET.gpsTime.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
  public var nsTimestamp: Int64 { let o = _accessor.offset(VTOFFSET.nsTimestamp.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
  public var latitude: Double { let o = _accessor.offset(VTOFFSET.latitude.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var longitude: Double { let o = _accessor.offset(VTOFFSET.longitude.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var altitude: Double { let o = _accessor.offset(VTOFFSET.altitude.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var accuracy: Double { let o = _accessor.offset(VTOFFSET.accuracy.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var provider: String? { let o = _accessor.offset(VTOFFSET.provider.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var providerSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.provider.v) }
  public var speed: Double { let o = _accessor.offset(VTOFFSET.speed.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var bearing: Double { let o = _accessor.offset(VTOFFSET.bearing.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var speedAccuracy: Double { let o = _accessor.offset(VTOFFSET.speedAccuracy.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var verticalAccuracy: Double { let o = _accessor.offset(VTOFFSET.verticalAccuracy.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var bearingAccuracy: Double { let o = _accessor.offset(VTOFFSET.bearingAccuracy.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var floorDisplayName: String? { let o = _accessor.offset(VTOFFSET.floorDisplayName.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var floorDisplayNameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.floorDisplayName.v) }
  public var parkingLotId: Int64 { let o = _accessor.offset(VTOFFSET.parkingLotId.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
  public var sourceCode: String? { let o = _accessor.offset(VTOFFSET.sourceCode.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var sourceCodeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.sourceCode.v) }
  public var validity: Bool { let o = _accessor.offset(VTOFFSET.validity.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public static func startFBINDOOR_LOC(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 18) }
  public static func add(reqId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: reqId, at: VTOFFSET.reqId.p) }
  public static func add(msTime: Int64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: msTime, def: 0, at: VTOFFSET.msTime.p) }
  public static func add(gpsTime: Int64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: gpsTime, def: 0, at: VTOFFSET.gpsTime.p) }
  public static func add(nsTimestamp: Int64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: nsTimestamp, def: 0, at: VTOFFSET.nsTimestamp.p) }
  public static func add(latitude: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: latitude, def: 0.0, at: VTOFFSET.latitude.p) }
  public static func add(longitude: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: longitude, def: 0.0, at: VTOFFSET.longitude.p) }
  public static func add(altitude: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: altitude, def: 0.0, at: VTOFFSET.altitude.p) }
  public static func add(accuracy: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: accuracy, def: 0.0, at: VTOFFSET.accuracy.p) }
  public static func add(provider: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: provider, at: VTOFFSET.provider.p) }
  public static func add(speed: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: speed, def: 0.0, at: VTOFFSET.speed.p) }
  public static func add(bearing: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: bearing, def: 0.0, at: VTOFFSET.bearing.p) }
  public static func add(speedAccuracy: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: speedAccuracy, def: 0.0, at: VTOFFSET.speedAccuracy.p) }
  public static func add(verticalAccuracy: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: verticalAccuracy, def: 0.0, at: VTOFFSET.verticalAccuracy.p) }
  public static func add(bearingAccuracy: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: bearingAccuracy, def: 0.0, at: VTOFFSET.bearingAccuracy.p) }
  public static func add(floorDisplayName: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: floorDisplayName, at: VTOFFSET.floorDisplayName.p) }
  public static func add(parkingLotId: Int64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: parkingLotId, def: 0, at: VTOFFSET.parkingLotId.p) }
  public static func add(sourceCode: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: sourceCode, at: VTOFFSET.sourceCode.p) }
  public static func add(validity: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: validity, def: false,
   at: VTOFFSET.validity.p) }
  public static func endFBINDOOR_LOC(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createFBINDOOR_LOC(
    _ fbb: inout FlatBufferBuilder,
    reqIdOffset reqId: Offset = Offset(),
    msTime: Int64 = 0,
    gpsTime: Int64 = 0,
    nsTimestamp: Int64 = 0,
    latitude: Double = 0.0,
    longitude: Double = 0.0,
    altitude: Double = 0.0,
    accuracy: Double = 0.0,
    providerOffset provider: Offset = Offset(),
    speed: Double = 0.0,
    bearing: Double = 0.0,
    speedAccuracy: Double = 0.0,
    verticalAccuracy: Double = 0.0,
    bearingAccuracy: Double = 0.0,
    floorDisplayNameOffset floorDisplayName: Offset = Offset(),
    parkingLotId: Int64 = 0,
    sourceCodeOffset sourceCode: Offset = Offset(),
    validity: Bool = false
  ) -> Offset {
    let __start = FBINDOOR_LOC.startFBINDOOR_LOC(&fbb)
    FBINDOOR_LOC.add(reqId: reqId, &fbb)
    FBINDOOR_LOC.add(msTime: msTime, &fbb)
    FBINDOOR_LOC.add(gpsTime: gpsTime, &fbb)
    FBINDOOR_LOC.add(nsTimestamp: nsTimestamp, &fbb)
    FBINDOOR_LOC.add(latitude: latitude, &fbb)
    FBINDOOR_LOC.add(longitude: longitude, &fbb)
    FBINDOOR_LOC.add(altitude: altitude, &fbb)
    FBINDOOR_LOC.add(accuracy: accuracy, &fbb)
    FBINDOOR_LOC.add(provider: provider, &fbb)
    FBINDOOR_LOC.add(speed: speed, &fbb)
    FBINDOOR_LOC.add(bearing: bearing, &fbb)
    FBINDOOR_LOC.add(speedAccuracy: speedAccuracy, &fbb)
    FBINDOOR_LOC.add(verticalAccuracy: verticalAccuracy, &fbb)
    FBINDOOR_LOC.add(bearingAccuracy: bearingAccuracy, &fbb)
    FBINDOOR_LOC.add(floorDisplayName: floorDisplayName, &fbb)
    FBINDOOR_LOC.add(parkingLotId: parkingLotId, &fbb)
    FBINDOOR_LOC.add(sourceCode: sourceCode, &fbb)
    FBINDOOR_LOC.add(validity: validity, &fbb)
    return FBINDOOR_LOC.endFBINDOOR_LOC(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.reqId.p, fieldName: "reqId", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.msTime.p, fieldName: "msTime", required: false, type: Int64.self)
    try _v.visit(field: VTOFFSET.gpsTime.p, fieldName: "gpsTime", required: false, type: Int64.self)
    try _v.visit(field: VTOFFSET.nsTimestamp.p, fieldName: "nsTimestamp", required: false, type: Int64.self)
    try _v.visit(field: VTOFFSET.latitude.p, fieldName: "latitude", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.longitude.p, fieldName: "longitude", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.altitude.p, fieldName: "altitude", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.accuracy.p, fieldName: "accuracy", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.provider.p, fieldName: "provider", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.speed.p, fieldName: "speed", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.bearing.p, fieldName: "bearing", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.speedAccuracy.p, fieldName: "speedAccuracy", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.verticalAccuracy.p, fieldName: "verticalAccuracy", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.bearingAccuracy.p, fieldName: "bearingAccuracy", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.floorDisplayName.p, fieldName: "floorDisplayName", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.parkingLotId.p, fieldName: "parkingLotId", required: false, type: Int64.self)
    try _v.visit(field: VTOFFSET.sourceCode.p, fieldName: "sourceCode", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.validity.p, fieldName: "validity", required: false, type: Bool.self)
    _v.finish()
  }
}

public struct FBINDOOR_LOCs: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_2_10() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case indoorLocs = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var hasIndoorLocs: Bool { let o = _accessor.offset(VTOFFSET.indoorLocs.v); return o == 0 ? false : true }
  public var indoorLocsCount: Int32 { let o = _accessor.offset(VTOFFSET.indoorLocs.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func indoorLocs(at index: Int32) -> FBINDOOR_LOC? { let o = _accessor.offset(VTOFFSET.indoorLocs.v); return o == 0 ? nil : FBINDOOR_LOC(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startFBINDOOR_LOCs(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func addVectorOf(indoorLocs: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: indoorLocs, at: VTOFFSET.indoorLocs.p) }
  public static func endFBINDOOR_LOCs(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createFBINDOOR_LOCs(
    _ fbb: inout FlatBufferBuilder,
    indoorLocsVectorOffset indoorLocs: Offset = Offset()
  ) -> Offset {
    let __start = FBINDOOR_LOCs.startFBINDOOR_LOCs(&fbb)
    FBINDOOR_LOCs.addVectorOf(indoorLocs: indoorLocs, &fbb)
    return FBINDOOR_LOCs.endFBINDOOR_LOCs(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.indoorLocs.p, fieldName: "indoorLocs", required: false, type: ForwardOffset<Vector<ForwardOffset<FBINDOOR_LOC>, FBINDOOR_LOC>>.self)
    _v.finish()
  }
}

public struct FBINDOOR_RAW: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_2_10() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case reqId = 4
    case msTime = 6
    case mobileTime = 8
    case buildingName = 10
    case levelName = 12
    case scc = 14
    case scr = 16
    case x = 18
    case y = 20
    case absoluteHeading = 22
    case velocity = 24
    case phase = 26
    case calculatedTime = 28
    case mode = 30
    case validity = 32
    case indoorValidity = 34
    case indoorValidityFlag = 36
    case bleOnlyPosition = 38
    case tjIndoorStatus = 40
    case isIndoor = 42
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var reqId: String? { let o = _accessor.offset(VTOFFSET.reqId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var reqIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.reqId.v) }
  public var msTime: Int64 { let o = _accessor.offset(VTOFFSET.msTime.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
  public var mobileTime: Int64 { let o = _accessor.offset(VTOFFSET.mobileTime.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
  public var buildingName: String? { let o = _accessor.offset(VTOFFSET.buildingName.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var buildingNameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.buildingName.v) }
  public var levelName: String? { let o = _accessor.offset(VTOFFSET.levelName.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var levelNameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.levelName.v) }
  public var scc: Double { let o = _accessor.offset(VTOFFSET.scc.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var scr: Double { let o = _accessor.offset(VTOFFSET.scr.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var x: Double { let o = _accessor.offset(VTOFFSET.x.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var y: Double { let o = _accessor.offset(VTOFFSET.y.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var absoluteHeading: Double { let o = _accessor.offset(VTOFFSET.absoluteHeading.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var velocity: Double { let o = _accessor.offset(VTOFFSET.velocity.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var phase: Int64 { let o = _accessor.offset(VTOFFSET.phase.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
  public var calculatedTime: Double { let o = _accessor.offset(VTOFFSET.calculatedTime.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var mode: String? { let o = _accessor.offset(VTOFFSET.mode.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var modeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.mode.v) }
  public var validity: Bool { let o = _accessor.offset(VTOFFSET.validity.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public var indoorValidity: Bool { let o = _accessor.offset(VTOFFSET.indoorValidity.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public var indoorValidityFlag: Int64 { let o = _accessor.offset(VTOFFSET.indoorValidityFlag.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
  public var bleOnlyPosition: Bool { let o = _accessor.offset(VTOFFSET.bleOnlyPosition.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public var tjIndoorStatus: Int64 { let o = _accessor.offset(VTOFFSET.tjIndoorStatus.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
  public var isIndoor: Bool { let o = _accessor.offset(VTOFFSET.isIndoor.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public static func startFBINDOOR_RAW(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 20) }
  public static func add(reqId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: reqId, at: VTOFFSET.reqId.p) }
  public static func add(msTime: Int64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: msTime, def: 0, at: VTOFFSET.msTime.p) }
  public static func add(mobileTime: Int64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: mobileTime, def: 0, at: VTOFFSET.mobileTime.p) }
  public static func add(buildingName: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: buildingName, at: VTOFFSET.buildingName.p) }
  public static func add(levelName: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: levelName, at: VTOFFSET.levelName.p) }
  public static func add(scc: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: scc, def: 0.0, at: VTOFFSET.scc.p) }
  public static func add(scr: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: scr, def: 0.0, at: VTOFFSET.scr.p) }
  public static func add(x: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: x, def: 0.0, at: VTOFFSET.x.p) }
  public static func add(y: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: y, def: 0.0, at: VTOFFSET.y.p) }
  public static func add(absoluteHeading: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: absoluteHeading, def: 0.0, at: VTOFFSET.absoluteHeading.p) }
  public static func add(velocity: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: velocity, def: 0.0, at: VTOFFSET.velocity.p) }
  public static func add(phase: Int64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: phase, def: 0, at: VTOFFSET.phase.p) }
  public static func add(calculatedTime: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: calculatedTime, def: 0.0, at: VTOFFSET.calculatedTime.p) }
  public static func add(mode: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: mode, at: VTOFFSET.mode.p) }
  public static func add(validity: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: validity, def: false,
   at: VTOFFSET.validity.p) }
  public static func add(indoorValidity: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: indoorValidity, def: false,
   at: VTOFFSET.indoorValidity.p) }
  public static func add(indoorValidityFlag: Int64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: indoorValidityFlag, def: 0, at: VTOFFSET.indoorValidityFlag.p) }
  public static func add(bleOnlyPosition: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: bleOnlyPosition, def: false,
   at: VTOFFSET.bleOnlyPosition.p) }
  public static func add(tjIndoorStatus: Int64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: tjIndoorStatus, def: 0, at: VTOFFSET.tjIndoorStatus.p) }
  public static func add(isIndoor: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: isIndoor, def: false,
   at: VTOFFSET.isIndoor.p) }
  public static func endFBINDOOR_RAW(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createFBINDOOR_RAW(
    _ fbb: inout FlatBufferBuilder,
    reqIdOffset reqId: Offset = Offset(),
    msTime: Int64 = 0,
    mobileTime: Int64 = 0,
    buildingNameOffset buildingName: Offset = Offset(),
    levelNameOffset levelName: Offset = Offset(),
    scc: Double = 0.0,
    scr: Double = 0.0,
    x: Double = 0.0,
    y: Double = 0.0,
    absoluteHeading: Double = 0.0,
    velocity: Double = 0.0,
    phase: Int64 = 0,
    calculatedTime: Double = 0.0,
    modeOffset mode: Offset = Offset(),
    validity: Bool = false,
    indoorValidity: Bool = false,
    indoorValidityFlag: Int64 = 0,
    bleOnlyPosition: Bool = false,
    tjIndoorStatus: Int64 = 0,
    isIndoor: Bool = false
  ) -> Offset {
    let __start = FBINDOOR_RAW.startFBINDOOR_RAW(&fbb)
    FBINDOOR_RAW.add(reqId: reqId, &fbb)
    FBINDOOR_RAW.add(msTime: msTime, &fbb)
    FBINDOOR_RAW.add(mobileTime: mobileTime, &fbb)
    FBINDOOR_RAW.add(buildingName: buildingName, &fbb)
    FBINDOOR_RAW.add(levelName: levelName, &fbb)
    FBINDOOR_RAW.add(scc: scc, &fbb)
    FBINDOOR_RAW.add(scr: scr, &fbb)
    FBINDOOR_RAW.add(x: x, &fbb)
    FBINDOOR_RAW.add(y: y, &fbb)
    FBINDOOR_RAW.add(absoluteHeading: absoluteHeading, &fbb)
    FBINDOOR_RAW.add(velocity: velocity, &fbb)
    FBINDOOR_RAW.add(phase: phase, &fbb)
    FBINDOOR_RAW.add(calculatedTime: calculatedTime, &fbb)
    FBINDOOR_RAW.add(mode: mode, &fbb)
    FBINDOOR_RAW.add(validity: validity, &fbb)
    FBINDOOR_RAW.add(indoorValidity: indoorValidity, &fbb)
    FBINDOOR_RAW.add(indoorValidityFlag: indoorValidityFlag, &fbb)
    FBINDOOR_RAW.add(bleOnlyPosition: bleOnlyPosition, &fbb)
    FBINDOOR_RAW.add(tjIndoorStatus: tjIndoorStatus, &fbb)
    FBINDOOR_RAW.add(isIndoor: isIndoor, &fbb)
    return FBINDOOR_RAW.endFBINDOOR_RAW(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.reqId.p, fieldName: "reqId", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.msTime.p, fieldName: "msTime", required: false, type: Int64.self)
    try _v.visit(field: VTOFFSET.mobileTime.p, fieldName: "mobileTime", required: false, type: Int64.self)
    try _v.visit(field: VTOFFSET.buildingName.p, fieldName: "buildingName", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.levelName.p, fieldName: "levelName", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.scc.p, fieldName: "scc", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.scr.p, fieldName: "scr", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.x.p, fieldName: "x", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.y.p, fieldName: "y", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.absoluteHeading.p, fieldName: "absoluteHeading", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.velocity.p, fieldName: "velocity", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.phase.p, fieldName: "phase", required: false, type: Int64.self)
    try _v.visit(field: VTOFFSET.calculatedTime.p, fieldName: "calculatedTime", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.mode.p, fieldName: "mode", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.validity.p, fieldName: "validity", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.indoorValidity.p, fieldName: "indoorValidity", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.indoorValidityFlag.p, fieldName: "indoorValidityFlag", required: false, type: Int64.self)
    try _v.visit(field: VTOFFSET.bleOnlyPosition.p, fieldName: "bleOnlyPosition", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.tjIndoorStatus.p, fieldName: "tjIndoorStatus", required: false, type: Int64.self)
    try _v.visit(field: VTOFFSET.isIndoor.p, fieldName: "isIndoor", required: false, type: Bool.self)
    _v.finish()
  }
}

public struct FBINDOOR_RAWs: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_2_10() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case indoorRaws = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var hasIndoorRaws: Bool { let o = _accessor.offset(VTOFFSET.indoorRaws.v); return o == 0 ? false : true }
  public var indoorRawsCount: Int32 { let o = _accessor.offset(VTOFFSET.indoorRaws.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func indoorRaws(at index: Int32) -> FBINDOOR_RAW? { let o = _accessor.offset(VTOFFSET.indoorRaws.v); return o == 0 ? nil : FBINDOOR_RAW(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startFBINDOOR_RAWs(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func addVectorOf(indoorRaws: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: indoorRaws, at: VTOFFSET.indoorRaws.p) }
  public static func endFBINDOOR_RAWs(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createFBINDOOR_RAWs(
    _ fbb: inout FlatBufferBuilder,
    indoorRawsVectorOffset indoorRaws: Offset = Offset()
  ) -> Offset {
    let __start = FBINDOOR_RAWs.startFBINDOOR_RAWs(&fbb)
    FBINDOOR_RAWs.addVectorOf(indoorRaws: indoorRaws, &fbb)
    return FBINDOOR_RAWs.endFBINDOOR_RAWs(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.indoorRaws.p, fieldName: "indoorRaws", required: false, type: ForwardOffset<Vector<ForwardOffset<FBINDOOR_RAW>, FBINDOOR_RAW>>.self)
    _v.finish()
  }
}

public struct FBMETA: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_2_10() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case reqId = 4
    case appId = 6
    case osVersion = 8
    case device = 10
    case os = 12
    case msg = 14
    case mockCode = 16
    case sdkVersion = 18
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var reqId: String? { let o = _accessor.offset(VTOFFSET.reqId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var reqIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.reqId.v) }
  public var appId: String? { let o = _accessor.offset(VTOFFSET.appId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var appIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.appId.v) }
  public var osVersion: String? { let o = _accessor.offset(VTOFFSET.osVersion.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var osVersionSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.osVersion.v) }
  public var device: String? { let o = _accessor.offset(VTOFFSET.device.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var deviceSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.device.v) }
  public var os: String? { let o = _accessor.offset(VTOFFSET.os.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var osSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.os.v) }
  public var msg: String? { let o = _accessor.offset(VTOFFSET.msg.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var msgSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.msg.v) }
  public var mockCode: Int64 { let o = _accessor.offset(VTOFFSET.mockCode.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
  public var sdkVersion: String? { let o = _accessor.offset(VTOFFSET.sdkVersion.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var sdkVersionSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.sdkVersion.v) }
  public static func startFBMETA(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 8) }
  public static func add(reqId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: reqId, at: VTOFFSET.reqId.p) }
  public static func add(appId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: appId, at: VTOFFSET.appId.p) }
  public static func add(osVersion: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: osVersion, at: VTOFFSET.osVersion.p) }
  public static func add(device: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: device, at: VTOFFSET.device.p) }
  public static func add(os: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: os, at: VTOFFSET.os.p) }
  public static func add(msg: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: msg, at: VTOFFSET.msg.p) }
  public static func add(mockCode: Int64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: mockCode, def: 0, at: VTOFFSET.mockCode.p) }
  public static func add(sdkVersion: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: sdkVersion, at: VTOFFSET.sdkVersion.p) }
  public static func endFBMETA(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createFBMETA(
    _ fbb: inout FlatBufferBuilder,
    reqIdOffset reqId: Offset = Offset(),
    appIdOffset appId: Offset = Offset(),
    osVersionOffset osVersion: Offset = Offset(),
    deviceOffset device: Offset = Offset(),
    osOffset os: Offset = Offset(),
    msgOffset msg: Offset = Offset(),
    mockCode: Int64 = 0,
    sdkVersionOffset sdkVersion: Offset = Offset()
  ) -> Offset {
    let __start = FBMETA.startFBMETA(&fbb)
    FBMETA.add(reqId: reqId, &fbb)
    FBMETA.add(appId: appId, &fbb)
    FBMETA.add(osVersion: osVersion, &fbb)
    FBMETA.add(device: device, &fbb)
    FBMETA.add(os: os, &fbb)
    FBMETA.add(msg: msg, &fbb)
    FBMETA.add(mockCode: mockCode, &fbb)
    FBMETA.add(sdkVersion: sdkVersion, &fbb)
    return FBMETA.endFBMETA(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.reqId.p, fieldName: "reqId", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.appId.p, fieldName: "appId", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.osVersion.p, fieldName: "osVersion", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.device.p, fieldName: "device", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.os.p, fieldName: "os", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.msg.p, fieldName: "msg", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.mockCode.p, fieldName: "mockCode", required: false, type: Int64.self)
    try _v.visit(field: VTOFFSET.sdkVersion.p, fieldName: "sdkVersion", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

public struct FBMETAs: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_2_10() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case metas = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var hasMetas: Bool { let o = _accessor.offset(VTOFFSET.metas.v); return o == 0 ? false : true }
  public var metasCount: Int32 { let o = _accessor.offset(VTOFFSET.metas.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func metas(at index: Int32) -> FBMETA? { let o = _accessor.offset(VTOFFSET.metas.v); return o == 0 ? nil : FBMETA(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startFBMETAs(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func addVectorOf(metas: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: metas, at: VTOFFSET.metas.p) }
  public static func endFBMETAs(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createFBMETAs(
    _ fbb: inout FlatBufferBuilder,
    metasVectorOffset metas: Offset = Offset()
  ) -> Offset {
    let __start = FBMETAs.startFBMETAs(&fbb)
    FBMETAs.addVectorOf(metas: metas, &fbb)
    return FBMETAs.endFBMETAs(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.metas.p, fieldName: "metas", required: false, type: ForwardOffset<Vector<ForwardOffset<FBMETA>, FBMETA>>.self)
    _v.finish()
  }
}

public struct FBPOSITION: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_2_10() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case reqId = 4
    case msTime = 6
    case gpsTime = 8
    case nsTimestamp = 10
    case latitude = 12
    case longitude = 14
    case altitude = 16
    case accuracy = 18
    case provider = 20
    case speed = 22
    case bearing = 24
    case speedAccuracy = 26
    case verticalAccuracy = 28
    case bearingAccuracy = 30
    case floorDisplayName = 32
    case parkingLotId = 34
    case sourceCode = 36
    case inOutStatus = 38
    case parkingZone = 40
    case isValid = 42
    case filter = 44
    case estimatedTimeLag = 46
    case time = 48
    case openSkyAccuracy = 50
    case isBackground = 52
    case isCarConnected = 54
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var reqId: String? { let o = _accessor.offset(VTOFFSET.reqId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var reqIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.reqId.v) }
  public var msTime: Int64 { let o = _accessor.offset(VTOFFSET.msTime.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
  public var gpsTime: Int64 { let o = _accessor.offset(VTOFFSET.gpsTime.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
  public var nsTimestamp: Int64 { let o = _accessor.offset(VTOFFSET.nsTimestamp.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
  public var latitude: Double { let o = _accessor.offset(VTOFFSET.latitude.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var longitude: Double { let o = _accessor.offset(VTOFFSET.longitude.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var altitude: Double { let o = _accessor.offset(VTOFFSET.altitude.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var accuracy: Double { let o = _accessor.offset(VTOFFSET.accuracy.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var provider: String? { let o = _accessor.offset(VTOFFSET.provider.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var providerSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.provider.v) }
  public var speed: Double { let o = _accessor.offset(VTOFFSET.speed.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var bearing: Double { let o = _accessor.offset(VTOFFSET.bearing.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var speedAccuracy: Double { let o = _accessor.offset(VTOFFSET.speedAccuracy.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var verticalAccuracy: Double { let o = _accessor.offset(VTOFFSET.verticalAccuracy.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var bearingAccuracy: Double { let o = _accessor.offset(VTOFFSET.bearingAccuracy.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var floorDisplayName: String? { let o = _accessor.offset(VTOFFSET.floorDisplayName.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var floorDisplayNameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.floorDisplayName.v) }
  public var parkingLotId: Int64 { let o = _accessor.offset(VTOFFSET.parkingLotId.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
  public var sourceCode: String? { let o = _accessor.offset(VTOFFSET.sourceCode.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var sourceCodeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.sourceCode.v) }
  public var inOutStatus: Int64 { let o = _accessor.offset(VTOFFSET.inOutStatus.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
  public var parkingZone: String? { let o = _accessor.offset(VTOFFSET.parkingZone.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var parkingZoneSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.parkingZone.v) }
  public var isValid: Bool { let o = _accessor.offset(VTOFFSET.isValid.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public var filter: String? { let o = _accessor.offset(VTOFFSET.filter.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var filterSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.filter.v) }
  public var estimatedTimeLag: Int64 { let o = _accessor.offset(VTOFFSET.estimatedTimeLag.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
  public var time: Int64 { let o = _accessor.offset(VTOFFSET.time.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
  public var openSkyAccuracy: Double { let o = _accessor.offset(VTOFFSET.openSkyAccuracy.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var isBackground: Bool { let o = _accessor.offset(VTOFFSET.isBackground.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public var isCarConnected: Bool { let o = _accessor.offset(VTOFFSET.isCarConnected.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public static func startFBPOSITION(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 26) }
  public static func add(reqId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: reqId, at: VTOFFSET.reqId.p) }
  public static func add(msTime: Int64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: msTime, def: 0, at: VTOFFSET.msTime.p) }
  public static func add(gpsTime: Int64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: gpsTime, def: 0, at: VTOFFSET.gpsTime.p) }
  public static func add(nsTimestamp: Int64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: nsTimestamp, def: 0, at: VTOFFSET.nsTimestamp.p) }
  public static func add(latitude: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: latitude, def: 0.0, at: VTOFFSET.latitude.p) }
  public static func add(longitude: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: longitude, def: 0.0, at: VTOFFSET.longitude.p) }
  public static func add(altitude: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: altitude, def: 0.0, at: VTOFFSET.altitude.p) }
  public static func add(accuracy: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: accuracy, def: 0.0, at: VTOFFSET.accuracy.p) }
  public static func add(provider: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: provider, at: VTOFFSET.provider.p) }
  public static func add(speed: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: speed, def: 0.0, at: VTOFFSET.speed.p) }
  public static func add(bearing: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: bearing, def: 0.0, at: VTOFFSET.bearing.p) }
  public static func add(speedAccuracy: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: speedAccuracy, def: 0.0, at: VTOFFSET.speedAccuracy.p) }
  public static func add(verticalAccuracy: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: verticalAccuracy, def: 0.0, at: VTOFFSET.verticalAccuracy.p) }
  public static func add(bearingAccuracy: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: bearingAccuracy, def: 0.0, at: VTOFFSET.bearingAccuracy.p) }
  public static func add(floorDisplayName: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: floorDisplayName, at: VTOFFSET.floorDisplayName.p) }
  public static func add(parkingLotId: Int64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: parkingLotId, def: 0, at: VTOFFSET.parkingLotId.p) }
  public static func add(sourceCode: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: sourceCode, at: VTOFFSET.sourceCode.p) }
  public static func add(inOutStatus: Int64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: inOutStatus, def: 0, at: VTOFFSET.inOutStatus.p) }
  public static func add(parkingZone: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: parkingZone, at: VTOFFSET.parkingZone.p) }
  public static func add(isValid: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: isValid, def: false,
   at: VTOFFSET.isValid.p) }
  public static func add(filter: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: filter, at: VTOFFSET.filter.p) }
  public static func add(estimatedTimeLag: Int64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: estimatedTimeLag, def: 0, at: VTOFFSET.estimatedTimeLag.p) }
  public static func add(time: Int64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: time, def: 0, at: VTOFFSET.time.p) }
  public static func add(openSkyAccuracy: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: openSkyAccuracy, def: 0.0, at: VTOFFSET.openSkyAccuracy.p) }
  public static func add(isBackground: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: isBackground, def: false,
   at: VTOFFSET.isBackground.p) }
  public static func add(isCarConnected: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: isCarConnected, def: false,
   at: VTOFFSET.isCarConnected.p) }
  public static func endFBPOSITION(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createFBPOSITION(
    _ fbb: inout FlatBufferBuilder,
    reqIdOffset reqId: Offset = Offset(),
    msTime: Int64 = 0,
    gpsTime: Int64 = 0,
    nsTimestamp: Int64 = 0,
    latitude: Double = 0.0,
    longitude: Double = 0.0,
    altitude: Double = 0.0,
    accuracy: Double = 0.0,
    providerOffset provider: Offset = Offset(),
    speed: Double = 0.0,
    bearing: Double = 0.0,
    speedAccuracy: Double = 0.0,
    verticalAccuracy: Double = 0.0,
    bearingAccuracy: Double = 0.0,
    floorDisplayNameOffset floorDisplayName: Offset = Offset(),
    parkingLotId: Int64 = 0,
    sourceCodeOffset sourceCode: Offset = Offset(),
    inOutStatus: Int64 = 0,
    parkingZoneOffset parkingZone: Offset = Offset(),
    isValid: Bool = false,
    filterOffset filter: Offset = Offset(),
    estimatedTimeLag: Int64 = 0,
    time: Int64 = 0,
    openSkyAccuracy: Double = 0.0,
    isBackground: Bool = false,
    isCarConnected: Bool = false
  ) -> Offset {
    let __start = FBPOSITION.startFBPOSITION(&fbb)
    FBPOSITION.add(reqId: reqId, &fbb)
    FBPOSITION.add(msTime: msTime, &fbb)
    FBPOSITION.add(gpsTime: gpsTime, &fbb)
    FBPOSITION.add(nsTimestamp: nsTimestamp, &fbb)
    FBPOSITION.add(latitude: latitude, &fbb)
    FBPOSITION.add(longitude: longitude, &fbb)
    FBPOSITION.add(altitude: altitude, &fbb)
    FBPOSITION.add(accuracy: accuracy, &fbb)
    FBPOSITION.add(provider: provider, &fbb)
    FBPOSITION.add(speed: speed, &fbb)
    FBPOSITION.add(bearing: bearing, &fbb)
    FBPOSITION.add(speedAccuracy: speedAccuracy, &fbb)
    FBPOSITION.add(verticalAccuracy: verticalAccuracy, &fbb)
    FBPOSITION.add(bearingAccuracy: bearingAccuracy, &fbb)
    FBPOSITION.add(floorDisplayName: floorDisplayName, &fbb)
    FBPOSITION.add(parkingLotId: parkingLotId, &fbb)
    FBPOSITION.add(sourceCode: sourceCode, &fbb)
    FBPOSITION.add(inOutStatus: inOutStatus, &fbb)
    FBPOSITION.add(parkingZone: parkingZone, &fbb)
    FBPOSITION.add(isValid: isValid, &fbb)
    FBPOSITION.add(filter: filter, &fbb)
    FBPOSITION.add(estimatedTimeLag: estimatedTimeLag, &fbb)
    FBPOSITION.add(time: time, &fbb)
    FBPOSITION.add(openSkyAccuracy: openSkyAccuracy, &fbb)
    FBPOSITION.add(isBackground: isBackground, &fbb)
    FBPOSITION.add(isCarConnected: isCarConnected, &fbb)
    return FBPOSITION.endFBPOSITION(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.reqId.p, fieldName: "reqId", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.msTime.p, fieldName: "msTime", required: false, type: Int64.self)
    try _v.visit(field: VTOFFSET.gpsTime.p, fieldName: "gpsTime", required: false, type: Int64.self)
    try _v.visit(field: VTOFFSET.nsTimestamp.p, fieldName: "nsTimestamp", required: false, type: Int64.self)
    try _v.visit(field: VTOFFSET.latitude.p, fieldName: "latitude", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.longitude.p, fieldName: "longitude", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.altitude.p, fieldName: "altitude", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.accuracy.p, fieldName: "accuracy", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.provider.p, fieldName: "provider", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.speed.p, fieldName: "speed", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.bearing.p, fieldName: "bearing", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.speedAccuracy.p, fieldName: "speedAccuracy", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.verticalAccuracy.p, fieldName: "verticalAccuracy", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.bearingAccuracy.p, fieldName: "bearingAccuracy", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.floorDisplayName.p, fieldName: "floorDisplayName", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.parkingLotId.p, fieldName: "parkingLotId", required: false, type: Int64.self)
    try _v.visit(field: VTOFFSET.sourceCode.p, fieldName: "sourceCode", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.inOutStatus.p, fieldName: "inOutStatus", required: false, type: Int64.self)
    try _v.visit(field: VTOFFSET.parkingZone.p, fieldName: "parkingZone", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.isValid.p, fieldName: "isValid", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.filter.p, fieldName: "filter", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.estimatedTimeLag.p, fieldName: "estimatedTimeLag", required: false, type: Int64.self)
    try _v.visit(field: VTOFFSET.time.p, fieldName: "time", required: false, type: Int64.self)
    try _v.visit(field: VTOFFSET.openSkyAccuracy.p, fieldName: "openSkyAccuracy", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.isBackground.p, fieldName: "isBackground", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.isCarConnected.p, fieldName: "isCarConnected", required: false, type: Bool.self)
    _v.finish()
  }
}

public struct FBPOSITIONs: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_2_10() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case positions = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var hasPositions: Bool { let o = _accessor.offset(VTOFFSET.positions.v); return o == 0 ? false : true }
  public var positionsCount: Int32 { let o = _accessor.offset(VTOFFSET.positions.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func positions(at index: Int32) -> FBPOSITION? { let o = _accessor.offset(VTOFFSET.positions.v); return o == 0 ? nil : FBPOSITION(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startFBPOSITIONs(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func addVectorOf(positions: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: positions, at: VTOFFSET.positions.p) }
  public static func endFBPOSITIONs(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createFBPOSITIONs(
    _ fbb: inout FlatBufferBuilder,
    positionsVectorOffset positions: Offset = Offset()
  ) -> Offset {
    let __start = FBPOSITIONs.startFBPOSITIONs(&fbb)
    FBPOSITIONs.addVectorOf(positions: positions, &fbb)
    return FBPOSITIONs.endFBPOSITIONs(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.positions.p, fieldName: "positions", required: false, type: ForwardOffset<Vector<ForwardOffset<FBPOSITION>, FBPOSITION>>.self)
    _v.finish()
  }
}

public struct FBPRESSURE: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_2_10() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case reqId = 4
    case msTime = 6
    case nsTimestamp = 8
    case pressure = 10
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var reqId: String? { let o = _accessor.offset(VTOFFSET.reqId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var reqIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.reqId.v) }
  public var msTime: Int64 { let o = _accessor.offset(VTOFFSET.msTime.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
  public var nsTimestamp: Int64 { let o = _accessor.offset(VTOFFSET.nsTimestamp.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
  public var pressure: Float32 { let o = _accessor.offset(VTOFFSET.pressure.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public static func startFBPRESSURE(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 4) }
  public static func add(reqId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: reqId, at: VTOFFSET.reqId.p) }
  public static func add(msTime: Int64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: msTime, def: 0, at: VTOFFSET.msTime.p) }
  public static func add(nsTimestamp: Int64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: nsTimestamp, def: 0, at: VTOFFSET.nsTimestamp.p) }
  public static func add(pressure: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: pressure, def: 0.0, at: VTOFFSET.pressure.p) }
  public static func endFBPRESSURE(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createFBPRESSURE(
    _ fbb: inout FlatBufferBuilder,
    reqIdOffset reqId: Offset = Offset(),
    msTime: Int64 = 0,
    nsTimestamp: Int64 = 0,
    pressure: Float32 = 0.0
  ) -> Offset {
    let __start = FBPRESSURE.startFBPRESSURE(&fbb)
    FBPRESSURE.add(reqId: reqId, &fbb)
    FBPRESSURE.add(msTime: msTime, &fbb)
    FBPRESSURE.add(nsTimestamp: nsTimestamp, &fbb)
    FBPRESSURE.add(pressure: pressure, &fbb)
    return FBPRESSURE.endFBPRESSURE(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.reqId.p, fieldName: "reqId", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.msTime.p, fieldName: "msTime", required: false, type: Int64.self)
    try _v.visit(field: VTOFFSET.nsTimestamp.p, fieldName: "nsTimestamp", required: false, type: Int64.self)
    try _v.visit(field: VTOFFSET.pressure.p, fieldName: "pressure", required: false, type: Float32.self)
    _v.finish()
  }
}

public struct FBPRESSUREs: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_2_10() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case pressures = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var hasPressures: Bool { let o = _accessor.offset(VTOFFSET.pressures.v); return o == 0 ? false : true }
  public var pressuresCount: Int32 { let o = _accessor.offset(VTOFFSET.pressures.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func pressures(at index: Int32) -> FBPRESSURE? { let o = _accessor.offset(VTOFFSET.pressures.v); return o == 0 ? nil : FBPRESSURE(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startFBPRESSUREs(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func addVectorOf(pressures: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: pressures, at: VTOFFSET.pressures.p) }
  public static func endFBPRESSUREs(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createFBPRESSUREs(
    _ fbb: inout FlatBufferBuilder,
    pressuresVectorOffset pressures: Offset = Offset()
  ) -> Offset {
    let __start = FBPRESSUREs.startFBPRESSUREs(&fbb)
    FBPRESSUREs.addVectorOf(pressures: pressures, &fbb)
    return FBPRESSUREs.endFBPRESSUREs(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.pressures.p, fieldName: "pressures", required: false, type: ForwardOffset<Vector<ForwardOffset<FBPRESSURE>, FBPRESSURE>>.self)
    _v.finish()
  }
}

public struct FBLOG: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_2_10() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case log = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var log: String? { let o = _accessor.offset(VTOFFSET.log.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var logSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.log.v) }
  public static func startFBLOG(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func add(log: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: log, at: VTOFFSET.log.p) }
  public static func endFBLOG(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createFBLOG(
    _ fbb: inout FlatBufferBuilder,
    logOffset log: Offset = Offset()
  ) -> Offset {
    let __start = FBLOG.startFBLOG(&fbb)
    FBLOG.add(log: log, &fbb)
    return FBLOG.endFBLOG(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.log.p, fieldName: "log", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

